Java接口和抽象类
抽象类：
包含抽象方法的类称为抽象类，但并不意味着抽象类中只有抽象方法；
抽象类是为继承而存在的
1：抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法）；
2：抽象类不能用来创建对象；
3：如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。

接口：
它是对行为的抽象，接口中可以含有变量和方法；
接口中的变量会被隐式地指定为public static final变量，而方法会被隐式地指定为public abstract；
接口中的所有方法不能有具体的实现，也就是说必须是抽象方法；

对于遵循某个接口的抽象类，可以不实现接口中的抽象方法。

两者差异：
1：抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；
2：抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
3：接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4：一个类只能继承一个抽象类，而一个类却可以实现多个接口。


Java的static关键字
用途：方便在没有创建对象的情况下来进行调用（方法/变量）
被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。


Java内部类
常规内部类，静态内部类，局部内部类，匿名内部类

常规内部类（没有用static修饰且定义在外部类类体中）：
常规内部类中的方法可以直接使用外部类的实例变量和实例方法
常规内部类中可以直接用内部类创建对象

静态内部类：
静态内部类与静态内部方法相似，只能访问外部类的static成员，不能直接访问外部类的实例变量与实例方法，只有通过对象引用才能访问

局部内部类：
在方法体或语句块（包括方法，构造方法，局部块或静态初始化块）内部定义的类
局部内部类不能加任何访问修饰符，因为它只对局部块有效，在定义的方法体外不能创建局部内部类的对象
方法中的内部类可以访问外部类成员，对于方法的参数和局部变量，必修有final修饰才可以访问

匿名内部类：
定义一个类的最终目的是创建一个类的实例，但是如果某个类的实例只是使用一次，则可以将类的定义与类的创建放到一起完成
或者说在定义类的同时就创建一个类
1：匿名内部类可以继承一个类或实现一个接口，但是不能同时实现一个接口和继承一个类，也不能实现多个接口
2：如果实现了一个接口，改类是Object类的直接子类，匿名类继承一个类或实现一个接口，不需要extends和implements关键字
3：由于匿名内部类没有名称，所以类体中不能定义构造方法，由于不知道类名也不能使用关键字来创建该类的实例。
TypeName obj=new Name（）{
   /*此处为类体*/
}


关于排序算法：
内排序
插入排序：直接插入排序，shell排序
选择排序：简单选择排序，堆排序
交换排序：冒泡排序，快速排序
归并排序
线性时间排序：基数排序，桶排序

稳定：直接插入排序，冒泡排序，归并排序，基数排序

直接插入排序：
基本思想：每步将一个待排序的记录，按其关键字的大小插入到已经排好序的有序数组中
空间复杂度：O(1)
最好时间复杂度：O(n)，最坏时间复杂度:O(n^2)，平均时间复杂度：O(n^2)
最好情况下：数组已有序，比较次数n-1，移动次数0

希尔排序：
减少了直接插入排序元素的移动次数，比快排慢但是比插入排序快

简单选择排序：
基本思想：每次选择一个最小的元素存放到数组的起始位置
空间复杂度O(1)，最好/最坏/平均时间复杂度都是O(n^2)，比较次数O(n^2)，移动次数O(n)

堆排序：
空间复杂度O(1)，平均时间复杂度O（n log n），依次堆调整O(log n)——即堆的高度。
由于建初始堆所需的比较次数较多，所以堆排序不适宜记录数量较少的情况

快速排序：
基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，
        然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

最好空间复杂度O(log(n))，最坏空间复杂度O（n），平均空间复杂度O(log n)；最好时间复杂度O(n log n)，
最坏时间复杂度O(n^2)，平均时间复杂度O(n log n)。

最好情况下：Partition每次划分得很均匀
最坏情况下：待排序的序列为正序或者逆序，没次划分只得到比上一次划分少一个记录的子序列，注意另一个为空
          此时需要执行n-1次递归调用


关于网路协议：

DNS
作用：将主机名和域名转换为IP地址
属于应用层协议
DNS查询过程如下：
1：在浏览器里输入www.qq.com域名，操作系统会先检查自己本地hosts文件是否有这个网址映射关系，如果有，
就先调用这个IP地址映射，完成域名解析
2：如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存
3：如果没有，首先会找TCP/IP参数中设置的首选DNS服务器，即本地DNS服务器，此解析具有权威性
4：如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了次网址映射关系，则调用这个IP地址映射
完成域名解析，此解析不具有权威性
5：如果本地DNS服务器本地区域文件和缓存解析都失败，则根据本地DNS服务器的设置进行查询
如果未用转发模式，直接到顶级域名服务器，再往下一级一级解析
6：如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析
上一级服务器如果不能解析，或找根DNS或把请求转至上上级，一次循环。


关于TCP
TCP建立连接要进行3次握手，而断开连接要进行4次，这是由于TCP的半关闭造成的
因为TCP连接是全双工的，所以进行关闭时每个方向都要单独进行关闭
关闭的方法是一方完成它的数据传输后，就发送一个FIN来向另一方通告将要终止这个方向的连接
当一端收到一个FIN，它必须通知应用层TCP连接已终止了这个方向的数据传送，发送FIN通常是应用层进行关闭的结果

为什么不能两次握手进行连接？
有可能发生死锁，假定A给B发送一个连接请求分组，B收到了这个分组，并发送了确认应答分组。
按照两次握手的协定，B认为连接已经成功地建立了，可以开始发送数组分组。
可是，A在B的应答分组在传输中被丢失的情况下，将不知道B是否已经准备好，不知道B建立什么样的序列号
A甚至怀疑B是否收到自己的连接请求分组。
在这种情况下，A认为连接还未建立成功，将忽略B发送来的任何数据分组，只等待连接确认应答分组。
而B在发出分组超时后，重复发送同样的分组。
这样就形成了死锁。

采用三次握手是：为了防止失效的连接请求报文突然又传送到主机B，因而产生错误
失效的连接请求报文是指：主机A发出的连接请求没有收到B的确认，于是经过一段时间后，
主机A有重新向主机B发送连接请求，且建立成功，顺序完成数据传输。
考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B
主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认
此时主机A根本不会理会，主机B就一直等待主机A发送数据，导致主机B的资源浪费




