Java接口和抽象类
抽象类：
包含抽象方法的类称为抽象类，但并不意味着抽象类中只有抽象方法；
抽象类是为继承而存在的
1：抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法）；
2：抽象类不能用来创建对象；
3：如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。

接口：
它是对行为的抽象，接口中可以含有变量和方法；
接口中的变量会被隐式地指定为public static final变量，而方法会被隐式地指定为public abstract；
接口中的所有方法不能有具体的实现，也就是说必须是抽象方法；

对于遵循某个接口的抽象类，可以不实现接口中的抽象方法。

两者差异：
1：抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；
2：抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
3：接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4：一个类只能继承一个抽象类，而一个类却可以实现多个接口。


Java的static关键字
用途：方便在没有创建对象的情况下来进行调用（方法/变量）
被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。


Java内部类
常规内部类，静态内部类，局部内部类，匿名内部类

常规内部类（没有用static修饰且定义在外部类类体中）：
常规内部类中的方法可以直接使用外部类的实例变量和实例方法
常规内部类中可以直接用内部类创建对象

静态内部类：
静态内部类与静态内部方法相似，只能访问外部类的static成员，不能直接访问外部类的实例变量与实例方法，只有通过对象引用才能访问

局部内部类：
在方法体或语句块（包括方法，构造方法，局部块或静态初始化块）内部定义的类
局部内部类不能加任何访问修饰符，因为它只对局部块有效，在定义的方法体外不能创建局部内部类的对象
方法中的内部类可以访问外部类成员，对于方法的参数和局部变量，必须有final修饰才可以访问

匿名内部类：
定义一个类的最终目的是创建一个类的实例，但是如果某个类的实例只是使用一次，则可以将类的定义与类的创建放到一起完成
或者说在定义类的同时就创建一个类
1：匿名内部类可以继承一个类或实现一个接口，但是不能同时实现一个接口和继承一个类，也不能实现多个接口
2：如果实现了一个接口，该类是Object类的直接子类，匿名类继承一个类或实现一个接口，不需要extends和implements关键字
3：由于匿名内部类没有名称，所以类体中不能定义构造方法，由于不知道类名也不能使用关键字来创建该类的实例。
TypeName obj=new Name（）{
   /*此处为类体*/
}


关于排序算法：
内排序
插入排序：直接插入排序，shell排序
选择排序：简单选择排序，堆排序
交换排序：冒泡排序，快速排序
归并排序
线性时间排序：基数排序，桶排序

稳定：直接插入排序，冒泡排序，归并排序，基数排序

直接插入排序：
基本思想：每步将一个待排序的记录，按其关键字的大小插入到已经排好序的有序数组中
空间复杂度：O(1)
最好时间复杂度：O(n)，最坏时间复杂度:O(n^2)，平均时间复杂度：O(n^2)
最好情况下：数组已有序，比较次数n-1，移动次数0

希尔排序：
减少了直接插入排序元素的移动次数，比快排慢但是比插入排序快

简单选择排序：
基本思想：每次选择一个最小的元素存放到数组的起始位置
空间复杂度O(1)，最好/最坏/平均时间复杂度都是O(n^2)，比较次数O(n^2)，移动次数O(n)

堆排序：
空间复杂度O(1)，平均时间复杂度O（n log n），依次堆调整O(log n)——即堆的高度。
由于建初始堆所需的比较次数较多，所以堆排序不适宜记录数量较少的情况

快速排序：
基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，
        然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

最好空间复杂度O(log(n))，最坏空间复杂度O（n），平均空间复杂度O(log n)；最好时间复杂度O(n log n)，
最坏时间复杂度O(n^2)，平均时间复杂度O(n log n)。

最好情况下：Partition每次划分得很均匀
最坏情况下：待排序的序列为正序或者逆序，没次划分只得到比上一次划分少一个记录的子序列，注意另一个为空
          此时需要执行n-1次递归调用


关于网路协议：

DNS
作用：将主机名和域名转换为IP地址
属于应用层协议
DNS查询过程如下：
1：在浏览器里输入www.qq.com域名，操作系统会先检查自己本地hosts文件是否有这个网址映射关系，如果有，
就先调用这个IP地址映射，完成域名解析
2：如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存
3：如果没有，首先会找TCP/IP参数中设置的首选DNS服务器，即本地DNS服务器，此解析具有权威性
4：如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了次网址映射关系，则调用这个IP地址映射
完成域名解析，此解析不具有权威性
5：如果本地DNS服务器本地区域文件和缓存解析都失败，则根据本地DNS服务器的设置进行查询
如果未用转发模式，直接到顶级域名服务器，再往下一级一级解析
6：如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析
上一级服务器如果不能解析，或找根DNS或把请求转至上上级，一次循环。


关于TCP
TCP建立连接要进行3次握手，而断开连接要进行4次，这是由于TCP的半关闭造成的
因为TCP连接是全双工的，所以进行关闭时每个方向都要单独进行关闭
关闭的方法是一方完成它的数据传输后，就发送一个FIN来向另一方通告将要终止这个方向的连接
当一端收到一个FIN，它必须通知应用层TCP连接已终止了这个方向的数据传送，发送FIN通常是应用层进行关闭的结果

为什么不能两次握手进行连接？
有可能发生死锁，假定A给B发送一个连接请求分组，B收到了这个分组，并发送了确认应答分组。
按照两次握手的协定，B认为连接已经成功地建立了，可以开始发送数组分组。
可是，A在B的应答分组在传输中被丢失的情况下，将不知道B是否已经准备好，不知道B建立什么样的序列号
A甚至怀疑B是否收到自己的连接请求分组。
在这种情况下，A认为连接还未建立成功，将忽略B发送来的任何数据分组，只等待连接确认应答分组。
而B在发出分组超时后，重复发送同样的分组。
这样就形成了死锁。

采用三次握手是：为了防止失效的连接请求报文突然又传送到主机B，因而产生错误
失效的连接请求报文是指：主机A发出的连接请求没有收到B的确认，于是经过一段时间后，
主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。
考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B
主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认
此时主机A根本不会理会，主机B就一直等待主机A发送数据，导致主机B的资源浪费


linux守护进程
linux服务器在启动时需要启动很多系统服务，它们向本地和网络用户提供了linux的系统功能接口，直接面向应用程序和用户。
提供这些服务的程序是由运行在后台的守护进程（daemons）来执行的。
作业规划进程crond，打印进程lqd
工作方式：
stand-alone工作模式：负载高的（sendmail，Apache）
xinetd模式：超级管理服务器
查看目前运行的守护进程：pstree


Java中会存在内存泄漏吗
理论上Java因为会有垃圾回收机制（GC）不会存在内存泄漏问题；然而在实际开发中，可能会存在无用但可达的对象
这些对象不能被GC回收，因此也会导致内存泄漏的发生。


Java设计模式
单例设计模式：
构造方法私有化，防止被实例化
保证在一个JVM中，该对象只有一个实例存在，这样的模式有几个好处：
1：某些类创建比较频繁，对于一些大型的对象，这是一笔很大的开销
2：省去了new操作符，降低了系统内存的使用频率，减轻GC压力
3：有些类如交易所的核心交易系统，控制着交易流程，如果该类可以创建
  多个的话，系统完全乱了，(比如一个军队出现了多个司令员同时指挥，肯定会乱成
  一团)，所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。


简单工厂模式：
就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建
好处：增加一个功能，无需去改动现成的代码，扩展性较好


Java反射机制
什么是java的反射：
Java的反射机制是在编译时并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审
使用的是在编译期并不知道的类。这样的编译特点就是java反射

反射是java语言的一个特性，它允许程序在运行时来进行自我检查并且对内部成员进行操作。



java反射的作用：
假如有两个程序员，一个程序员在写程序的时需要使用第二个程序员所写的类，但第二个程序员并没完成他所写的类。
那么第一个程序员的代码是不能通过编译的。此时，利用Java反射的机制，就可以让第一个程序员在没有得到第二个程序员所写的类的时候，
来完成自身代码的编译。


Java注解


怎样判断一个单链表有没有环
定义两个指针h1，h2都从头开始遍历单链表，h1每次向前走1步，h2每次向前走2步
如果h2碰到了NULL，说明环不存在；如果h2碰到本应在身后的h1说明环存在
如果环存在，h2与h1一定会相遇，而且相遇的点在环内：h2比h1遍历的速度快，一定不会在开始的那段非环的链表部分相遇，
所以当h1,h2都进入环后，h2每次移动都会使h2与h1之间在前进方向上的差距缩小1，最后，会使得h1和h2差距减少为0，也即相遇
代码如下：
int find_cicle(list *head)
{
     list *pFast=head;
     list *pSlow=head;
     if (pFast==NULL)
     {
          return -1;
      }
     while(pFast && pFast->next)
    {
        pFast=pFast->next->next;
        pSlow=pSlow->next;
        if (pFast==pSlow)
       {
           return 1;
        }
     }
     return 0
}



链表插入一个元素

查找单链表的中间结点：一个每次走一步，一个每次走两步

查找单链表中的倒数第k个节点
public static Node getKNode(Node head, int k) {
    Node target = head;
    Node nexk = head;
    for(int i = 0; i < k; i++) {
        nexk = nexk.next;
    }
    while (nexk != null) {
        target = target.next;
        nexk = nexk.next;
    }
    return target;
}




hashMap，hashTable和treeMap底层实现
hashMap和hashTable都是基于哈希表实现的
1：HashTable的方法是同步的，HaspMap未经同步
2：HashTable不允许null值，HashMap允许null值
3：HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。

treeMap基于红黑树实现

HashSet，treeSet和LinkedHashSet
Set接口
HashSet
不能保证元素的排列顺序
不是同步的

LinkedHashSet
LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。
这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。

TreeSet类
TreeSet可以确保集合元素处于排序状态

线程安全
在Java里，线程安全一般体现在两个方面：
1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关键字synchronized。
如ArrayList和Vector，HashMap和Hashtable
（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。
2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，
如像static、transient那样。





synchronize和volatile关键字
一旦一个共享变量被volatile修饰之后，那么就具备了两层语义
1：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
2：禁止进行指令重排序


vector，arrayList和LinkedList区别
List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。
Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，
避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。
LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。


什么情况下回发生内存泄漏
内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。
内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。

内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。
内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。

1、静态集合类引起内存泄露

2、各种连接
比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，
否则是不会自动被GC 回收的。

3、内部类和外部模块等的引用

笔试题复习：数字组合，和尚挑水

java序列化和反序列化
序列化就是把Java对象转换为字节序列的过程
实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上
利用序列化实现远程通信，即在网络上传送对象的字节序列
序列化后很占内存

hadoop的序列化的特点
1、紧凑：由于带宽是集群中信息传递的最宝贵的资源所以我们必须想法设法缩小传递信息的大小，
hadoop的序列化就为了更好地坐到这一点而设计的。
2、对象可重用：JDK的反序列化会不断地创建对象，这肯定会造成一定的系统开销，但是在hadoop的反序列化中，
能重复的利用一个对象的readField方法来重新产生不同的对象。
3、可扩展性：当前hadoop的序列化有多中选择
*可以利用实现hadoop的Writable接口。
*使用开源的序列化框架protocol Buffers，Avro等框架。

二分查找

this和super
this表示当前对象，也就是当前类对象，super表示当前类的父类


进程通信方式
管道：父子进程
有名管道：无亲缘关系
信号量：计数器
消息队列
信号
共享内存
套接字

线程通信方式
锁机制：互斥锁，条件变量，读写锁
信号量机制
信号机制


TCP控制字段
URG:Urget pointer is valid (紧急指针字段值有效)

SYN: 表示建立连接

FIN: 表示关闭连接

ACK: 表示响应

PSH: 表示有 DATA数据传输

RST: 表示连接重置。


创建索引
CREATE UNIQUE INDEX 索引名称
ON 表名称 (列名称)


scala和java的有哪些不同？
Spark 中用 Scala 和 java 开发的区别
构建系统的选择，sbt更适合用来构建scala工程，maven更适合用来构建java工程
scala简练，高效
java成熟，稳重
scala独有的函数式编程
函数是scala语言中的一等公民。
一等公民的特权表现在：1：函数可以传递、复制
                  2：scala中有嵌套函数和匿名函数
                  3：scala支持高阶函数
                  4：scala支持偏应用（偏函数）
                  5：scala支持闭包
举例来说：
1：可传递
def func(f:() => String) = println(f())
func(() => "hi")
output: hi

2：嵌套函数
嵌套函数在实际中应用场景不多，其中一个场景是将递归函数转为尾递归方式！
def fun1(){
  .....
  this
 }

def fun2(){
   ....
   this
 }
两个函数可以如下方式使用
 fun1().fun2()

3：函数柯里化
当函数具有多个参数时
def sum(x:Int,y:Int) = x + y
参数被打散后，两个参数分开
def sum2(x:Int)(y:Int) = x + y
sum2(1)(2)
output：3

3：闭包
在java中匿名内部类访问局部变量时，局部变量必须声明为final（类似闭包的实现）
def mulBy(factor: Double) = (x: Double) => factor * x


k-means聚类算法优缺点？
K-means算法缺点主要是：
1. 对异常值敏感
2. 需要提前确定k值

优点：
1. 计算时间段，速度快
2. 容易解释
3. 聚类效果还不错
